---
output: html_document
---

<!-- Setup -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---
title: "Definition Evaluation: `r params$report$query_title`"
author: `r params$start_date` to `r params$end_date`
---  
  
**Jurisdiction**: `r params$jurisdiction`  
**Report Created**: `r Sys.Date()`    
**Point of Contact**: `r DefinitionInformation[["Setup"]]$PointOfContact` (`r DefinitionInformation[["Setup"]]$POCEmail`)    
**Organization**: `r DefinitionInformation[["Setup"]]$Organization`


***  
### Definition Information  {.tabset}
  
Inclusion terms and codes are displayed in the table below (exclusion terms are not shown in the table)  

<!-- Definition #1 --> 

#### `r syndrome_eval_list[[1]]$setup$info$Syndrome` (`r syndrome_eval_list[[1]]$setup$info$Abbreviation`)   
  
**Total Visits Identified:**  
  
`r syndrome_eval_list[[1]]$analysis$total_pretty`  
  
**Query description:**    
  
`r syndrome_eval_list[[1]]$setup$info$Description`  
  
**Full query:**  
`r syndrome_eval_list[[1]]$setup$structure_print`  
  
```{r def1_table, echo=FALSE, message=FALSE, warning=FALSE}

DT::datatable(syndrome_eval_list[[1]]$analysis$elements_detected_table, 
              rownames = FALSE, 
              options = list(pageLength = nrow(syndrome_eval_list[[1]]$setup$structure), dom = "t"), 
              filter = "top", escape = FALSE)

```
  

<!-- Definition #2 --> 

`r if(params$n_queries_eval >= 2){paste0('#### ',syndrome_eval_list[[2]]$setup$info$Syndrome,' (',syndrome_eval_list[[2]]$setup$info$Abbreviation,')'}`

`r if(params$n_queries_eval >= 2){**Total Visits Identified:**}`
`r if(params$n_queries_eval >= 2){syndrome_eval_list[[2]]$analysis$total_pretty}`

`r if(params$n_queries_eval >= 2){**Query description:**}`
`r if(params$n_queries_eval >= 2){syndrome_eval_list[[2]]$setup$info$Description}`

`r if(params$n_queries_eval >= 2){**Full query:**}`
`r if(params$n_queries_eval >= 2){syndrome_eval_list[[2]]$setup$structure_print}`

```{r def2_table, echo=FALSE, message=FALSE, warning=FALSE}
if(params$n_queries_eval >= 2){
  
 DT::datatable(syndrome_eval_list[[2]]$analysis$elements_detected_table, 
              rownames = FALSE, 
              options = list(pageLength = nrow(syndrome_eval_list[[2]]$setup$structure), dom = "t"), 
              filter = "top", escape = FALSE)
}
```


<!-- Definition #3 --> 

`r if(params$n_queries_eval >= 3){paste0('#### ',syndrome_eval_list[[3]]$setup$info$Syndrome,' (',syndrome_eval_list[[3]]$setup$info$Abbreviation,')'}`

`r if(params$n_queries_eval >= 3){**Total Visits Identified:**}`
`r if(params$n_queries_eval >= 3){syndrome_eval_list[[3]]$analysis$total_pretty}`

`r if(params$n_queries_eval >= 3){**Query description:**}`
`r if(params$n_queries_eval >= 3){syndrome_eval_list[[3]]$setup$info$Description}`

`r if(params$n_queries_eval >= 3){**Full query:**}`
`r if(params$n_queries_eval >= 3){syndrome_eval_list[[3]]$setup$structure_print}`

```{r def3_table, echo=FALSE, message=FALSE, warning=FALSE}
if(params$n_queries_eval >= 3){
  
 DT::datatable(syndrome_eval_list[[3]]$analysis$elements_detected_table, 
              rownames = FALSE, 
              options = list(pageLength = nrow(syndrome_eval_list[[3]]$setup$structure), dom = "t"), 
              filter = "top", escape = FALSE)
}
```


  
***  
`r if(params$n_queries_eval >= 2){paste0('### Defintion Comparison')}`

<!-- Timeseries Comparison --> 

`r if(params$n_queries_eval == 1){paste0('#### Visits over time')}`
`r if(params$n_queries_eval >= 2){paste0('#### Visits by syndrome over time {.tabset}')}`

Use the slider at the bottom of the figures to adjust the start and end dates visible in the graph.   
  
`r if(params$n_queries_eval >= 2){paste0('#### Same Scale')}`

```{r ts_same_scale, echo=FALSE, message=FALSE, warning=FALSE}

## Initiate Plotly Plot
ts_plot_same <- plot_ly()

## Add lines for each definition
for(i in 1:params$n_queries_eval){
  
  ts_plot_same <- ts_plot_same %>%
    add_lines(data = syndrome_eval_list[[i]]$results$timeseries,
            x = ~Date, y = ~Visits, name = ~Syndrome,
            line = list(color = params$report$ts_linecolors[i]))
}
rm(i)

## Adding Layout
ts_plot_same %>%
  layout(
    hovermode = "compare",
    xaxis = list(
      range = c(params$start_date,params$end_date),
      rangeslider = list(type = "date", thickness = 0.1)))
```


`r if(params$n_queries_eval >= 2){paste0('#### Independent Scales')}`
 
```{r ts_separate_scale, echo=FALSE, message=FALSE, warning=FALSE}

## Define Storage List
list_ts_plot <- list()

for(i in 1:params$n_queries_eval){
  
  list_ts_plot[[i]] <- plot_ly() %>%
    add_lines(data = syndrome_eval_list[[i]]$results$timeseries,
            x = ~Date, y = ~Visits, name = ~Syndrome,
            line = list(color = params$report$ts_linecolors[i])) %>%
    layout(
    hovermode = "compare",
    xaxis = list(
      range = c(min(params$all_dates$Date),max(params$all_dates$Date)),
      rangeslider = list(type = "date", thickness = 0.1)))
}

switch(params$n_queries_eval,
       subplot(list_ts_plot[[1]]),
       subplot(list_ts_plot[[1]], list_ts_plot[[2]],
               nrows = 2, shareX = TRUE, margin = 0.05),
       subplot(list_ts_plot[[1]], list_ts_plot[[2]], list_ts_plot[[3]], 
               nrows = 3, shareX = TRUE, margin = 0.05))

```

<!-- Demographics Comparison --> 

`r if(params$n_queries_eval >= 2){paste0('#### Demographics Comparison)}`

```{r prep demographics table}

## Bind Demographic Data Together
df_demo <- switch(params$n_queries_eval,
                  bind_rows(syndrome_eval_list[[1]]$results$clean, .id = "id"),
                  bind_rows(syndrome_eval_list[[1]]$results$clean, syndrome_eval_list[[2]]$results$clean, .id = "id"),
                  bind_rows(syndrome_eval_list[[1]]$results$clean, syndrome_eval_list[[2]]$results$clean, 
                            syndrome_eval_list[[3]]$results$clean, .id = "id"))

df_demo <- df_demo %>%
  pivot_longer(.,
               cols = starts_with("def", ignore.case = FALSE),
               names_to = "Syndrome",
               values_to = "Present") %>%
  filter(!is.na(Present)) %>%
  mutate(Syndrome = case_when(
    Syndrome == 'def1' ~ params$queries[1],
    Syndrome == 'def2' ~ params$queries[2],
    Syndrome == 'def3' ~ params$queries[3],
    TRUE ~ NA))

```

```{r demographics_table_1, echo=FALSE, message=FALSE, warning=FALSE}

## Generate gtsummary table & convert to tibble for DT import
table <- df_demo %>%
  tbl_summary(include = c(AgeGroup, Sex, Race, Ethnicity), by = Syndrome) %>%
  add_p() %>%
  modify_header(label = "Demographic") %>%
  bold_labels() %>%
  as_tibble(.) %>% # https://www.danieldsjoberg.com/gtsummary/reference/as_tibble.gtsummary.html
  mutate(Demographic = str_remove_all(Demographic, pattern = "\\_"))
  
## Clean Names
names(table) <- str_remove_all(string = names(table), pattern = "\\*")

## Render gtsummary table in DT
table %>% 
  DT::datatable(rownames=FALSE, 
                options = list(pageLength = nrow(table), dom = "t"), filter = "top", escape = FALSE) %>%
  formatStyle(
    columns = 'Demographic',
    fontWeight = styleEqual(c("AgeGroup","Sex","Race","Ethnicity"),"bold")) # https://rstudio.github.io/DT/010-style.html

# It would be best if I could get Demographic Category headers into their own column (for searching)

```

```{r demographics_table_2, echo=FALSE, message=FALSE, warning=FALSE}

### EXTRA STEPS FOR NATIVE DT TABLE (DEMO_TABLE2)
demographics <- c("Race", "Ethnicity", "AgeGroup", "Sex")
list_demo_table <- list()

for(i in seq_along(demographics)){

  list_demo_table[[demographics[i]]] <- df_demo %>%
    group_by(Syndrome, !!sym(demographics[i])) %>%
    complete() %>% # Include factor levels with 0 counts.
    summarize(Count = n()) %>%
    mutate(Percent = Count / sum(Count) * 100)
}
rm(i)


demo_table <- bind_rows(list_demo_table) %>%
  pivot_longer(.,
               cols = -c("Syndrome","Count","Percent"),
               names_to = "Demographic",
               values_to = "Identity") %>%
  filter(!is.na(Identity)) %>%
  mutate(Percent = paste0(round(Percent,2),"%")) %>%
  select(Syndrome, Demographic, Identity, Count, Percent) %>%
  arrange(Syndrome, Demographic)

demo_table %>%
  DT::datatable()

```

<!-- Count Comparison --> 

`r if(params$n_queries_eval >= 2){paste0('#### The total number of visits identified by all definitions combined was **',syndrome_eval_list$defs_total_pretty,'**')}`
  
`r if(params$n_queries_eval >= 2){paste0('#### Number and percent of all identified visits captured by each definition:')}`

```{r def_summary, echo=FALSE, message=FALSE, warning=FALSE, fig.height=3}
if(params$n_queries_eval >= 2){

  all_def_summary <- syndrome_eval_list[[params$overlap_name]] %>%
  select(all_of(params$queries_abbrev)) %>%
  summarize(across(
    .cols = everything(),
    .fns = ~ sum(.))) %>%
  pivot_longer(., cols = everything(), names_to = "Def", values_to = "Count") %>%
  mutate(Total = syndrome_eval_list$defs_total,
         Percent = round(Count/Total,3),
         Percent.Display = paste0(Percent*100,"%"))

all_def_summary %>%
  ggplot(data=., aes(x = Percent, y = reorder(Def,Percent))) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=Count, x = Percent-.01), hjust="top", color = "white", size = 3) +
  geom_text(aes(label=Percent.Display, x = Percent+.01), hjust="bottom", color = "black", size = 3) +
  geom_segment(aes(x = 0, xend = 1, y = 0.4, yend = 0.4)) +
  scale_x_continuous(limits = c(0,1.2), expand = c(0,0), breaks = c(0,.25,.50,.75,1), labels = scales::percent_format()) +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none")  
}
```

`r if(params$n_queries_eval >= 2){paste0('#### Number and percent of all identified visits captured by each observed combination of definitions: {.tabset}')}`

```{r def_comparison, echo=FALSE, message=FALSE, warning=FALSE}
if(params$n_queries_eval >= 2){
  
  all_def_summary <- syndrome_eval_list[[params$overlap_name]] %>%
  count(Definitions, name = "Visits") %>%
  mutate(Total = syndrome_eval_list$defs_total,
         Percent = paste0(round(Visits/Total,3)*100,"%")) %>%
  replace_na(list(Visits=0, Percent="0%")) %>%
  arrange(desc(Visits))

  all_def_summary %>%
    DT::datatable(options = list(pageLength = nrow(all_def_summary), dom = "t"), filter = "top", escape = FALSE)
}
```

<!-- Overlap Diagrams --> 

`r if(params$n_queries_eval >= 2){paste0('##### Overlap plot, not to scale')}`

```{r venn, echo=FALSE, message=FALSE, warning=FALSE}
if(params$n_queries_eval >= 2){
 plot(eulerr::venn(syndrome_eval_list[[params$overlap_name]] %>% select(all_of(params$queries_abbrev))), 
      labels = TRUE, legend = list(side = "right"), quantities = TRUE)
}
```

`r if(params$n_queries_eval >= 2){paste0('##### Overlap plot, to scale')}`

```{r euler, echo=FALSE, message=FALSE, warning=FALSE}
if(params$n_queries_eval >= 2){
 plot(eulerr::euler(syndrome_eval_list[[params$overlap_name]] %>% select(all_of(params$queries_abbrev))), 
      labels = TRUE, legend = list(side = "right"), quantities = TRUE)
}
```
  
***

<!-- Text Mining --> 

### Text Mining
`r paste0('#### Top ', params$text_analysis_number_ngrams,' words (unigrams) and phrases (bigrams) for each definition and text analysis field:{.tabset}')`

```{r text_mining, echo=FALSE, message = FALSE, warning = FALSE, fig.width=10, fig.height=8}

## Create TM Lists
unigram_list <- list()
bigram_list <- list()


## Text Mine
for(i in 1:params$n_queries_eval){
  
  ## Unigrams
  unigram_list[[i]] <- syndrome_eval_list[[i]]$results$clean %>%
    textmine(df=., 
             variables = params$fields_text_analysis, 
             n_grams = 1, # Unigrams
             metric = "n", 
             top_n = params$text_analysis_number_ngrams, top_n_by_variable = TRUE)
  
  ## Bigrams
  bigram_list[[i]] <- syndrome_eval_list[[i]]$results$clean %>%
    textmine(df=., 
             variables = params$fields_text_analysis,
             n_grams = 2, # Bigrams
             metric = "n", 
             top_n = params$text_analysis_number_ngrams, top_n_by_variable = TRUE)
  
  names(unigram_list)[i] <- names(syndrome_eval_list)[i]
  names(bigram_list)[i] <- names(syndrome_eval_list)[i]
}
rm(i)


## Bind All Text Mining (of Individual Definition(s)) Together
unigrams <- bind_rows(unigram_list, .id = "def") %>%
  mutate(def = factor(def, levels = params$queries_abbrev)) %>% # To preserve ordering of defs (avoid alphabetic ordering)
  group_by(def, Field) %>%
  mutate(order = row_number(),
         order = fct_rev(as.factor(order))) %>%
  select(def, field = Field, order, everything())

bigrams <- bind_rows(bigram_list, .id = "def") %>%
  mutate(def = factor(def, levels = params$queries_abbrev)) %>% # To preserve ordering of defs (avoid alphabetic ordering)
  group_by(def, Field) %>%
  mutate(order = row_number(),
         order = fct_rev(as.factor(order))) %>%
  select(def, field = Field, order, everything())

rm(unigram_list, bigram_list)
```

`r paste0('##### Unigrams')`
```{r top_unigrams, echo=FALSE, message = FALSE, warning = FALSE, fig.width=10, fig.height=8}
bigrams %>% plot_tm(df=.)
```

`r paste0('##### Bigrams')`
```{r top_bigrams, echo=FALSE, message = FALSE, warning = FALSE, fig.width=10, fig.height=8}
bigrams %>% plot_tm(df=.)
```





```{r validation reviewer files, include=FALSE}
if(validation_review == TRUE){

# Development Note: I will attempt to keep all Reviewer columns the same across IE #'s (Reviewer_TP_## and Reviewer_Notes) and then seek to differentiate these columns across Reviewers after the joining where R will auto-assign .x.y.z etc prefixes. This will likely be easier to work with than generating code to scan a flexible # of uniquely generated var names. 

list <- list()

for(i in seq_along(validation_review_defs)){
  
  # Step 1: Formatting Data for Reviewers
  
  list[[i]] <- get(validation_review_defs[i]) %>%
    distinct(EssenceID, .keep_all = TRUE) %>% # Deduplicate records
    add_date_components(df=.) %>% # Generate Date Components (Date --> Weekday, Week, Month, Year)
    get_sample(df=.,
               sample_metric = SampleMetric,
               sample_value = SampleValue,
               strat_sample = StratifiedSample,
               strat_vars = StratifiedVariables) %>% # SAMPLE
    mutate(Review_Rating = NA,
          Notes = NA) %>%
    ## REORDER VARIABLES: BSI, REVIEWER VARS, EVERYTHING ELSE
    select(Date, EssenceID,
           Review_Rating, Notes,
           everything(),
           -Weekday, -Week, -Month, -Year) %>%
    ## REMOVE ALL CHARACTERS WHICH MAY CAUSE XML ERRORS WITH EXCEL FILES
    mutate(across(.cols = where(is.character), 
                  .fns = ~ str_replace_all(string=., pattern = "[^[:graph:]]", replacement = " "))) # Replace all non-printable characters with a space (to prevent XML encoding issues when writing EXCEL files). 
  
  # Step 2: Create folder name for each definition undergoing validation review
  
  def_review_folder <- name_def_review_folder(definition = validation_review_defs[i])
  
  # Step 3: Save Review Data (1 copy for each reviewer examining each definition)
  
  for(j in 1:n_reviewers){ # for each reviewer specified (j) create reviewer specific subfolder (within each definition being reviewed)
    
    list[[i]] %>%
      writexl::write_xlsx(x=., 
                 path = paste0(output_folder, "Validation_Review\\",def_review_folder,"\\1_Reviewed_Data\\Reviewer_",j,
                             "\\Reviewer_",j,"_Data.xlsx"))
  }
  
  # Step 4: Set up Consensus Review Code for each definition's Validation Review Folder
  
  # Problem: When folks are running SyS Eval_ template, they have not yet started validation review --> so not yet time for Comparison/Consensus process --> need an additional script/button they can run when ready (Consensus_Review.Rmd).
  
  # Step 4a: Create a filepath  for each definition validation review
  filepath <- paste0(output_folder, "Validation_Review\\", def_review_folder)
  
  # Step 4b: Save all parameters needed to run Consensus_Review.Rmd template
  save(filepath, DefinitionInformation,
       file = paste0(filepath,"\\Resources\\Validation_Review_Parameters.RData"))
  
  # Step 4c: Copy Validation Summary R Markdown code template(s) to each definition validation review folder.

  if(n_reviewers == 1){ # Consensus Review not feasible with 1 reviewer --> Singular Validation_Summary.Rmd
  
  file.copy(from = "SupportCode\\Validation_Review\\Validation_Summary.Rmd",
            to = paste0(filepath))
    
  }else if(n_reviewers > 1){ # Only include Post-Consensus Review RMD if there are enough reviewers to do Consensus Review.
    
  # Pre Consensus Review Code Template
  file.copy(from = "SupportCode\\Validation_Review\\Validation_Summary_Pre_Consensus_Review.Rmd",
            to = paste0(filepath))
    
  # Post Consensus Review Code Template
  file.copy(from = "SupportCode\\Validation_Review\\Validation_Summary_Post_Consensus_Review.Rmd",
            to = paste0(filepath))  
    }
  }
}
```
___
*The template for this report was created by Sara Chronister & Tyler Bonnell. For questions, ideas for improvement/collaboration, or attribution, please reach out to <sara.chronister@doh.wa.gov>.*