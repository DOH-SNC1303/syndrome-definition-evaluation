---
output: html_document
---

<!-- Setup -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---
title: "Definition Evaluation: `r params$report$query_title`"
author: `r params$start_date` to `r params$end_date`
---  
  
**Jurisdiction**: `r params$jurisdiction`  
**Report Created**: `r Sys.Date()`    
**Point of Contact**: `r DefinitionInformation[["Setup"]]$PointOfContact` (`r DefinitionInformation[["Setup"]]$POCEmail`)    
**Organization**: `r DefinitionInformation[["Setup"]]$Organization`


***  
### Definition Information  {.tabset}
  
Inclusion terms and codes are displayed in the table below (exclusion terms are not shown in the table)  

<!-- Definition #1 --> 

#### `r syndrome_eval_list[[1]]$setup$info$Syndrome` (`r syndrome_eval_list[[1]]$setup$info$Abbreviation`)   
  
**Total Visits Identified:**  
  
`r syndrome_eval_list[[1]]$analysis$total_pretty`  
  
**Query description:**    
  
`r syndrome_eval_list[[1]]$setup$info$Description`  
  
**Full query:**  
`r syndrome_eval_list[[1]]$setup$structure_print`  
  
```{r def1_table, echo=FALSE, message=FALSE, warning=FALSE}

DT::datatable(syndrome_eval_list[[1]]$analysis$elements_detected_table, 
              rownames = FALSE, 
              options = list(pageLength = nrow(syndrome_eval_list[[1]]$setup$structure), dom = "t"), 
              filter = "top", escape = FALSE)

```
  

<!-- Definition #2 --> 

`r if(params$n_queries_eval >= 2){paste0('#### ',syndrome_eval_list[[2]]$setup$info$Syndrome,' (',syndrome_eval_list[[2]]$setup$info$Abbreviation,')'}`

`r if(params$n_queries_eval >= 2){**Total Visits Identified:**}`
`r if(params$n_queries_eval >= 2){syndrome_eval_list[[2]]$analysis$total_pretty}`

`r if(params$n_queries_eval >= 2){**Query description:**}`
`r if(params$n_queries_eval >= 2){syndrome_eval_list[[2]]$setup$info$Description}`

`r if(params$n_queries_eval >= 2){**Full query:**}`
`r if(params$n_queries_eval >= 2){syndrome_eval_list[[2]]$setup$structure_print}`

```{r def2_table, echo=FALSE, message=FALSE, warning=FALSE}
if(params$n_queries_eval >= 2){
  
 DT::datatable(syndrome_eval_list[[2]]$analysis$elements_detected_table, 
              rownames = FALSE, 
              options = list(pageLength = nrow(syndrome_eval_list[[2]]$setup$structure), dom = "t"), 
              filter = "top", escape = FALSE)
}
```


<!-- Definition #3 --> 

`r if(params$n_queries_eval >= 3){paste0('#### ',syndrome_eval_list[[3]]$setup$info$Syndrome,' (',syndrome_eval_list[[3]]$setup$info$Abbreviation,')'}`

`r if(params$n_queries_eval >= 3){**Total Visits Identified:**}`
`r if(params$n_queries_eval >= 3){syndrome_eval_list[[3]]$analysis$total_pretty}`

`r if(params$n_queries_eval >= 3){**Query description:**}`
`r if(params$n_queries_eval >= 3){syndrome_eval_list[[3]]$setup$info$Description}`

`r if(params$n_queries_eval >= 3){**Full query:**}`
`r if(params$n_queries_eval >= 3){syndrome_eval_list[[3]]$setup$structure_print}`

```{r def3_table, echo=FALSE, message=FALSE, warning=FALSE}
if(params$n_queries_eval >= 3){
  
 DT::datatable(syndrome_eval_list[[3]]$analysis$elements_detected_table, 
              rownames = FALSE, 
              options = list(pageLength = nrow(syndrome_eval_list[[3]]$setup$structure), dom = "t"), 
              filter = "top", escape = FALSE)
}
```


  
***  
`r if(params$n_queries_eval >= 2){paste0('### Defintion Comparison')}`

`r if(params$n_queries_eval == 1){paste0('#### Visits over time')}`
`r if(params$n_queries_eval >= 2){paste0('#### Visits by syndrome over time {.tabset}')}`

Use the slider at the bottom of the figures to adjust the start and end dates visible in the graph.   
  
`r if(params$n_queries_eval >= 2){paste0('#### Same Scale')}`

```{r ts_same_scale, echo=FALSE, message=FALSE, warning=FALSE}

## Initiate Plotly Plot
ts_plot_same <- plot_ly()

## Add lines for each definition
for(i in 1:params$n_queries_eval){
  
  ts_plot_same <- ts_plot_same %>%
    add_lines(data = syndrome_eval_list[[i]]$results$timeseries,
            x = ~Date, y = ~Visits, name = ~Syndrome,
            line = list(color = params$report$ts_linecolors[i]))
}
rm(i)

## Adding Layout
ts_plot_same %>%
  layout(
    hovermode = "compare",
    xaxis = list(
      range = c(params$start_date,params$end_date),
      rangeslider = list(type = "date", thickness = 0.1)))
```


`r if(params$n_queries_eval >= 2){paste0('#### Independent Scales')}`
 
```{r ts_separate_scale, echo=FALSE, message=FALSE, warning=FALSE}
## Define Storage List
list_ts_plot <- list()

for(i in 1:params$n_queries_eval){
  
  list_ts_plot[[i]] <- plot_ly() %>%
    add_lines(data = syndrome_eval_list[[i]]$results$timeseries,
            x = ~Date, y = ~Visits, name = ~Syndrome,
            line = list(color = params$report$ts_linecolors[i])) %>%
    layout(
    hovermode = "compare",
    xaxis = list(
      range = c(min(params$all_dates$Date),max(params$all_dates$Date)),
      rangeslider = list(type = "date", thickness = 0.1)))
}

switch(params$n_queries_eval,
       subplot(list_ts_plot[[1]]),
       subplot(list_ts_plot[[1]], list_ts_plot[[2]],
               nrows = 2, shareX = TRUE, margin = 0.05),
       subplot(list_ts_plot[[1]], list_ts_plot[[2]], list_ts_plot[[3]], 
               nrows = 3, shareX = TRUE, margin = 0.05))

```

`r if(params$n_queries_eval >= 2){paste0('#### Demographics Comparison)}`

```{r demographics_table, echo=FALSE, message=FALSE, warning=FALSE}

df_demo <- switch(params$n_queries_eval,
                  bind_rows(syndrome_eval_list[[1]]$results$clean, .id = "id"),
                  bind_rows(syndrome_eval_list[[1]]$results$clean, syndrome_eval_list[[2]]$results$clean, .id = "id"),
                  bind_rows(syndrome_eval_list[[1]]$results$clean, syndrome_eval_list[[2]]$results$clean, 
                            syndrome_eval_list[[3]]$results$clean, .id = "id"))

df_demo <- df_demo %>%
  pivot_longer(.,
               cols = starts_with("def", ignore.case = FALSE),
               names_to = "Syndrome",
               values_to = "Present") %>%
  filter(!is.na(Present)) %>%
  mutate(Syndrome = case_when(
    Syndrome == 'def1' ~ params$queries[1],
    Syndrome == 'def2' ~ params$queries[2],
    Syndrome == 'def3' ~ params$queries[3],
    TRUE ~ NA))


demographics <- c("Race", "Ethnicity", "AgeGroup", "Sex")
list_demo_table <- list()
 
for(i in seq_along(demographics)){

  list_demo_table[[demographics[i]]] <- demo_table %>%
    group_by(!!sym(demographics[i])) %>%
    complete() %>% # Include factor levels with 0 counts.
    summarize(Count = n()) %>%
    mutate(Percent = Count / sum(Count) * 100)
}
rm(i)


demo_table <- bind_rows(list_demo_table) %>%
  pivot_longer(.,
               cols = -c("Count","Percent"),
               names_to = "Demographic",
               values_to = "Identity") %>%
  filter(!is.na(Identity)) %>%
  select(Demographic, Identity, Count, Percent) %>%
  arrange(Demographic)

demo_table %>%
  select(-Demographic) %>%
  DT::datatable(rownames = FALSE,
    extensions = 'RowGroup',
    options = list(rowGroup = list(dataSrc = 1)),
    colnames = c('', '', 'Count', 'Percent'))

```

  
  
#### The total number of visits identified by all definitions combined was **`r three_defs_total_pretty`**.   
  
#### Number and percent of all identified visits captured by each definition:        
```{r def_summary, echo=FALSE, message=FALSE, warning=FALSE, fig.height=3}

def1_results <- data.frame(Def = def1_name, Count = sum(three_defs_table$def1)) %>%
  mutate(Percent = round(Count/nrow(three_defs_table),3),
         Percent.Display = paste0(Percent*100,"%"))

def2_results <- data.frame(Def = def2_name, Count = sum(three_defs_table$def2)) %>%
  mutate(Percent = round(Count/nrow(three_defs_table),3),
         Percent.Display = paste0(Percent*100,"%"))

def3_results <- data.frame(Def = def3_name, Count = sum(three_defs_table$def3)) %>%
  mutate(Percent = round(Count/nrow(three_defs_table),3),
         Percent.Display = paste0(Percent*100,"%"))

all_def_results <- bind_rows(def1_results, def2_results, def3_results)


ggplot(data = all_def_results, aes(x = Percent, y = reorder(Def,Percent))) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=Count, x = Percent-.01), hjust="top", color = "white", size = 3) +
  geom_text(aes(label=Percent.Display, x = Percent+.01), hjust="bottom", color = "black", size = 3) +
  geom_segment(aes(x = 0, xend = 1, y = 0.4, yend = 0.4)) +
  scale_x_continuous(limits = c(0,1.2), expand = c(0,0), breaks = c(0,.25,.50,.75,1), labels = scales::percent_format()) +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none")


```
  
#### Number and percent of all identified visits captured by each observed combination of definitions: {.tabset}     
  
```{r def_comparison, echo=FALSE, message=FALSE, warning=FALSE}

three_defs_combinations <- data.frame(Definitions = 
                                        c(paste(def1_short,def2_short,sep=", "),
                                          paste(def1_short,def3_short,sep=", "),
                                          paste(def2_short,def3_short,sep=", "),
                                          paste(def1_short,def2_short,def3_short,sep=", "),
                                          paste0(def1_short),
                                          paste0(def2_short),
                                          paste0(def3_short)))

three_defs_summary <- three_defs_table %>%
  dplyr::count(Definitions, name = "Visits") %>%
  mutate(Percent = paste0(round(Visits/sum(Visits)*100,1),"%")) %>%
  full_join(three_defs_combinations) %>%
  replace_na(list(Visits=0,
                  Percent="0%")) %>%
  arrange(desc(Visits))

reactable(three_defs_summary)

```
  
##### Overlap plot, not to scale  
  
```{r venn, echo=FALSE, message=FALSE, warning=FALSE}

plot(venn(Def1_vs_Def2_vs_Def3[,which(colnames(Def1_vs_Def2_vs_Def3)==def1_short):which(colnames(Def1_vs_Def2_vs_Def3)==def3_short)]))

```
  
##### Overlap plot, to scale  
  
```{r euler, echo=FALSE, message=FALSE, warning=FALSE}

plot(euler(Def1_vs_Def2_vs_Def3[,which(colnames(Def1_vs_Def2_vs_Def3)==def1_short):which(colnames(Def1_vs_Def2_vs_Def3)==def3_short)]),quantities = TRUE)

```
  
  
***   
### Top terms (besides "patient")
#### Top 5 occurring terms for each definition and each field of interest:

```{r word_prep, echo=FALSE, message = FALSE, warning = FALSE, results='hide'}

my_file <- three_defs 

my_file <- clean_Admit_Reason_Combo()
my_file <- clean_ChiefComplaintOriginal()
my_file <- clean_ChiefComplaintUpdates()
my_file <- clean_ChiefComplaintParsed()
my_file <- clean_CCDD()
my_file <- clean_DischargeDiagnosis()
my_file <- clean_TriageNotesOrig()


```

```{r top_terms, echo=FALSE, message = FALSE, warning = FALSE, fig.width=10, fig.height=8}

def_sets <- list(my_file[my_file$def1==1,],
                 my_file[my_file$def2==1,],
                 my_file[my_file$def3==1,])

def_sets_names <- c(def1_short,def2_short,def3_short)

top_words <- list()
word_count <- list()

for (i in 1:length(def_sets)) {
  
  for(j in 1:length(select_fields)) {
    
    data <- as.data.frame(def_sets[i])
    
    field <- select_fields[j]
    
    word_count[[j]] <- data %>%
      dplyr::select(field) %>%
      unnest_tokens(word, !!field) %>%
      anti_join(stop_words, by = "word") %>%
      dplyr::count(word, name = "Count", sort=TRUE) %>%
      filter(word!="patient") %>%
      top_n(5) %>%
      mutate(def = def_sets_names[i],
             field = field)

    names(word_count)[[j]] <- select_fields[j]  
    
    }
  
  top_words[[i]] <- plyr::ldply(word_count, data.frame)

  names(top_words)[[i]] <- def_sets_names[i]
  
}

top_words_combined <- ldply(top_words, data.frame) %>%
  dplyr::arrange(Count) %>%
  group_by(def,field) %>%
  dplyr::mutate(order = row_number())

ggplot(data = top_words_combined) +
  geom_bar(aes(x = Count, y = as.factor(order)), stat="identity", fill = "#a4dba4") +
  geom_text(aes(x = 0, y = as.factor(order), label = paste0(word,'  (',Count,")"), hjust = "left"), size = 3) + 
  facet_grid(field ~ def, switch = "y", scales = "free") +
  theme_minimal() +
  theme(
    axis.text = element_blank(),
    panel.grid = element_blank(),
    strip.text.y.left = element_text(angle = 0),
    panel.background = element_rect(fill = NA, color = "grey40"),
    axis.title = element_blank()
  )

```

<!-- Writing Linelists -->

```{r output, echo=FALSE, message=FALSE, warning=FALSE}


# All Visits
write.csv(file = paste0(output_folder, "Three Defs All Visits.csv"),
          x = three_defs_table,
          row.names = FALSE)

# Def1 only
write.csv(file = paste0(output_folder,def1_short," Only Visits.csv"),
          x = three_defs_table[three_defs_table$def1_only==1,],
          row.names = FALSE)

# Def2 only
write.csv(file = paste0(output_folder,def2_short," Only Visits.csv"),
          x = three_defs_table[three_defs_table$def2_only==1,],
          row.names = FALSE)

# Def3 only
write.csv(file = paste0(output_folder,def3_short," Only Visits.csv"),
          x = three_defs_table[three_defs_table$def3_only==1,],
          row.names = FALSE)

# Def1 and Def2 
write.csv(file = paste0(output_folder,def1_short," and ",def2_short," Visits.csv"),
          x = three_defs_table[three_defs_table$def1_def2==1,],
          row.names = FALSE)

# Def1 and Def3 
write.csv(file = paste0(output_folder,def1_short," and ",def3_short," Visits.csv"),
          x = three_defs_table[three_defs_table$def1_def3==1,],
          row.names = FALSE)

# Def2 and Def3 
write.csv(file = paste0(output_folder,def2_short," and ",def3_short," Visits.csv"),
          x = three_defs_table[three_defs_table$def2_def3==1,],
          row.names = FALSE)

# Def1 and Def2 and Def3
write.csv(file = paste0(output_folder,def1_short, " and ",def2_short," and ",def3_short," Visits.csv"),
          x = three_defs_table[three_defs_table$All ==1,],
          row.names = FALSE)


# Create Matched Elements Subfolder
fs::dir_create(paste0(output_folder, "Matched_Elements"))

# Def1 matched elements
write.csv(file = paste0(output_folder,"Matched_Elements\\",def1_short," Matched Elements.csv"),
          x = def1_elements_detected,
          row.names = FALSE)

# Def2 matched elements
write.csv(file = paste0(output_folder,"Matched_Elements\\",def2_short," Matched Elements.csv"),
          x = def2_elements_detected,
          row.names = FALSE)

# Def3 matched elements
write.csv(file = paste0(output_folder,"Matched_Elements/",def3_short," Matched Elements.csv"),
          x = def3_elements_detected,
          row.names = FALSE)

```

<!-- Validation Review -->

```{r validation review setup, include=FALSE}

validation_review <- DefinitionInformation[["Setup"]]$ValidationReview


if(validation_review == TRUE){

## Identify # of Reviewers
n_reviewers <- DefinitionInformation[["ValidationReviewInformation"]]$ReviewerID %>% max()

# ## Identify Definitions to be Reviewed
validation_review_defs <- c("def1", "def2", "def3") # Change based on Evaluation Template #

## Establish Sampling Parameters
SampleMetric <- DefinitionInformation[["ValidationReviewInformation"]] %>% pull_no_na(df=., variable = "SampleMetric")
SampleValue <- DefinitionInformation[["ValidationReviewInformation"]] %>% pull_no_na(df=., variable = "SampleValue")
StratifiedSample <- DefinitionInformation[["ValidationReviewInformation"]] %>% pull_no_na(df=., variable = "StratifiedSample")
StratifiedVariables <- DefinitionInformation[["ValidationReviewInformation"]] %>% 
  pull_no_na(df=., variable = "StratifiedVariables") %>% # Pull StratifiedVariables (remove NAs)
  strsplit(., split = ",") %>% # Split single string "A, B" into a string vector c("A"," B") using the comma
  unlist() %>%  # Unlist (strsplit() puts new vector into a list)
  str_trim(., side="both") # Remove all whitespace on every string in the string vector: c("A", " B") --> c("A","B")

# Establish Review Scale
ReviewScaleLow <- DefinitionInformation[["ValidationReviewInformation"]]$ReviewScaleLow[1]
ReviewScaleHigh <- DefinitionInformation[["ValidationReviewInformation"]]$ReviewScaleHigh[1]

}
```

```{r validation review file directories, include=FALSE}
if(validation_review == TRUE){

## Create Validation Review File Directories

for(i in seq_along(validation_review_defs)){ # for each definition specified (i) create the following filepaths
  
  # Step 1: Create folder name for each definition undergoing validation review
  def_review_folder <- name_def_review_folder(definition = validation_review_defs[i])

  # Step 2: Create folders for each stage of a definition's validation review process
  fs::dir_create(paste0(output_folder, "Validation_Review\\",def_review_folder,"\\Resources"))
  fs::dir_create(paste0(output_folder, "Validation_Review\\",def_review_folder,"\\1_Reviewed_Data"))

  if(n_reviewers > 1){ # Only create consensus data folders if > 1 reviewer.
      fs::dir_create(paste0(output_folder, "Validation_Review\\",def_review_folder,"\\2_Consensus_Data"))
    }
  
  # Step 3: Create subfolders for each reviewer examining a definition
  for(j in 1:n_reviewers){ # for each reviewer specified (j) create reviewer specific subfolder (within each definition being reviewed)
    
  fs::dir_create(paste0(output_folder, "Validation_Review\\",def_review_folder,"\\1_Reviewed_Data\\Reviewer_",j))
    }
  }
rm(def_review_folder)
}
```

```{r validation reviewer files, include=FALSE}
if(validation_review == TRUE){

# Development Note: I will attempt to keep all Reviewer columns the same across IE #'s (Reviewer_TP_## and Reviewer_Notes) and then seek to differentiate these columns across Reviewers after the joining where R will auto-assign .x.y.z etc prefixes. This will likely be easier to work with than generating code to scan a flexible # of uniquely generated var names. 

list <- list()

for(i in seq_along(validation_review_defs)){
  
  # Step 1: Formatting Data for Reviewers
  
  list[[i]] <- get(validation_review_defs[i]) %>%
    distinct(EssenceID, .keep_all = TRUE) %>% # Deduplicate records
    add_date_components(df=.) %>% # Generate Date Components (Date --> Weekday, Week, Month, Year)
    get_sample(df=.,
               sample_metric = SampleMetric,
               sample_value = SampleValue,
               strat_sample = StratifiedSample,
               strat_vars = StratifiedVariables) %>% # SAMPLE
    mutate(Review_Rating = NA,
          Notes = NA) %>%
    ## REORDER VARIABLES: BSI, REVIEWER VARS, EVERYTHING ELSE
    select(Date, EssenceID,
           Review_Rating, Notes,
           everything(),
           -Weekday, -Week, -Month, -Year) %>%
    ## REMOVE ALL CHARACTERS WHICH MAY CAUSE XML ERRORS WITH EXCEL FILES
    mutate(across(.cols = where(is.character), 
                  .fns = ~ str_replace_all(string=., pattern = "[^[:graph:]]", replacement = " "))) # Replace all non-printable characters with a space (to prevent XML encoding issues when writing EXCEL files). 
  
  # Step 2: Create folder name for each definition undergoing validation review
  
  def_review_folder <- name_def_review_folder(definition = validation_review_defs[i])
  
  # Step 3: Save Review Data (1 copy for each reviewer examining each definition)
  
  for(j in 1:n_reviewers){ # for each reviewer specified (j) create reviewer specific subfolder (within each definition being reviewed)
    
    list[[i]] %>%
      writexl::write_xlsx(x=., 
                 path = paste0(output_folder, "Validation_Review\\",def_review_folder,"\\1_Reviewed_Data\\Reviewer_",j,
                             "\\Reviewer_",j,"_Data.xlsx"))
  }
  
  # Step 4: Set up Consensus Review Code for each definition's Validation Review Folder
  
  # Problem: When folks are running SyS Eval_ template, they have not yet started validation review --> so not yet time for Comparison/Consensus process --> need an additional script/button they can run when ready (Consensus_Review.Rmd).
  
  # Step 4a: Create a filepath  for each definition validation review
  filepath <- paste0(output_folder, "Validation_Review\\", def_review_folder)
  
  # Step 4b: Save all parameters needed to run Consensus_Review.Rmd template
  save(filepath, DefinitionInformation,
       file = paste0(filepath,"\\Resources\\Validation_Review_Parameters.RData"))
  
  # Step 4c: Copy Validation Summary R Markdown code template(s) to each definition validation review folder.

  if(n_reviewers == 1){ # Consensus Review not feasible with 1 reviewer --> Singular Validation_Summary.Rmd
  
  file.copy(from = "SupportCode\\Validation_Review\\Validation_Summary.Rmd",
            to = paste0(filepath))
    
  }else if(n_reviewers > 1){ # Only include Post-Consensus Review RMD if there are enough reviewers to do Consensus Review.
    
  # Pre Consensus Review Code Template
  file.copy(from = "SupportCode\\Validation_Review\\Validation_Summary_Pre_Consensus_Review.Rmd",
            to = paste0(filepath))
    
  # Post Consensus Review Code Template
  file.copy(from = "SupportCode\\Validation_Review\\Validation_Summary_Post_Consensus_Review.Rmd",
            to = paste0(filepath))  
    }
  }
}
```
___
*The template for this report was created by Sara Chronister. For questions, ideas for improvement/collaboration, or attribution, please reach out to <sara.chronister@doh.wa.gov>.*